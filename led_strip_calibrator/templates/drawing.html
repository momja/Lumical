<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LED Strip Interactive Drawing</title>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            color: white;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .control-group label {
            font-size: 14px;
        }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
        }

        button:hover {
            background-color: #45a049;
        }

        button.clear {
            background-color: #f44336;
        }

        button.clear:hover {
            background-color: #da190b;
        }

        input[type="color"] {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        input[type="range"] {
            width: 100px;
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        select {
            padding: 4px 8px;
            border: 1px solid #666;
            border-radius: 4px;
            background-color: #2a2a2a;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }

        select:focus {
            outline: none;
            border-color: #4CAF50;
        }

        .canvas-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-wrapper {
            text-align: center;
        }

        .canvas-wrapper h3 {
            margin-bottom: 10px;
        }

        canvas {
            border: 2px solid #666;
            border-radius: 8px;
            background-color: #000;
            cursor: crosshair;
        }

        .led-display {
            background-color: #2a2a2a;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .led-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .led-item {
            background-color: #333;
            border-radius: 4px;
            padding: 8px;
            text-align: center;
            border: 1px solid #555;
            position: relative;
        }

        .led-delete {
            position: absolute;
            top: 2px;
            right: 2px;
            background: #f44336;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
        }

        .led-delete:hover {
            background: #da190b;
        }

        .led-color {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            margin: 5px auto;
            border: 2px solid #666;
        }

        .status {
            background-color: #2a2a2a;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .canvas-container {
                flex-direction: column;
                align-items: center;
            }

            canvas {
                max-width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>LED Strip Interactive Drawing</h1>
            <p>Draw on the canvas to control your LED strip colors</p>
            <p><small><strong>Left-click:</strong> Draw â€¢ <strong>Right-click:</strong> Add new LED</small></p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="colorPicker">Color:</label>
                <input type="color" id="colorPicker" value="#ff0000">
            </div>

            <div class="control-group">
                <label for="brushSize">Brush Size:</label>
                <input type="range" id="brushSize" min="1" max="50" value="10">
                <span id="brushSizeValue">5</span>
            </div>

            <div class="control-group">
                <label for="knnK">K (neighbors):</label>
                <input type="range" id="knnK" min="1" max="10" value="3">
                <span id="knnKValue">3</span>
            </div>

            <div class="control-group">
                <label for="maxRadius">Max Radius:</label>
                <input type="range" id="maxRadius" min="0.01" max="0.5" step="0.01" value="0.25">
                <span id="maxRadiusValue">1.0</span>
            </div>

            <div class="control-group">
                <label for="blendMode">Blend Mode:</label>
                <select id="blendMode">
                    <option value="source-over">Normal</option>
                    <option value="multiply">Multiply</option>
                    <option value="screen">Screen</option>
                    <option value="overlay">Overlay</option>
                    <option value="soft-light">Soft Light</option>
                    <option value="hard-light">Hard Light</option>
                    <option value="color-dodge">Color Dodge</option>
                    <option value="color-burn">Color Burn</option>
                    <option value="darken">Darken</option>
                    <option value="lighten">Lighten</option>
                    <option value="difference">Difference</option>
                    <option value="exclusion">Exclusion</option>
                </select>
            </div>

            <div class="control-group">
                <label for="autoUpdate">Auto-update:</label>
                <input type="checkbox" id="autoUpdate">
            </div>

            <div class="control-group">
                <input type="file" id="imageFileInput" accept="image/*" style="display: none;">
                <button id="importImage">Import Image</button>
            </div>

            <button id="clearCanvas" class="clear">Clear Canvas</button>
            <button id="updateLEDs">Update LEDs</button>
        </div>

        <div class="canvas-container">
            <div class="canvas-wrapper">
                <h3>Drawing Canvas</h3>
                <canvas id="drawingCanvas" width="800" height="600"></canvas>
            </div>
            <div class="canvas-wrapper">
                <h3>LED Preview</h3>
                <canvas id="ledCanvas" width="800" height="600"></canvas>
            </div>
        </div>

        <div class="led-display">
            <h3>LED Colors</h3>
            <div style="margin-bottom: 15px;">
                <input type="file" id="csvFileInput" accept=".csv,text/csv" style="display: none;">
                <button id="importCSV" style="margin-right: 10px;">Import LED Coordinates</button>
                <button id="sampleColors" style="margin-right: 10px;">Sample Colors from Image</button>
                <button id="clearAll" class="clear">Clear All LEDs</button>
            </div>
            <div class="led-grid" id="ledGrid">
                <!-- LED color displays will be populated here -->
            </div>
        </div>

        <div class="status">
            <h3>Status</h3>
            <div id="statusText">Ready to draw</div>
            <div id="ledPositions">Loading LED positions...</div>
            <div id="mappingParams">K-NN Parameters: K=3, Max Radius=1.0</div>
        </div>
    </div>

    <script>
        class LEDDrawingApp {
            constructor() {
                this.canvas = document.getElementById('drawingCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.ledCanvas = document.getElementById('ledCanvas');
                this.ledCtx = this.ledCanvas.getContext('2d');
                this.isDrawing = false;
                this.drawingData = [];
                this.ledPositions = {};
                this.currentLedColors = {};
                this.autoUpdateTimeout = null;
                this.currentPath = []; // Track current stroke path
                this.currentStrokeColor = null;
                this.currentStrokeSize = null;
                this.currentBlendMode = null;

                // Create temporary canvas for current stroke preview
                this.tempCanvas = document.createElement('canvas');
                this.tempCanvas.width = this.canvas.width;
                this.tempCanvas.height = this.canvas.height;
                this.tempCtx = this.tempCanvas.getContext('2d');

                // Store canvas state before stroke starts
                this.canvasStateBeforeStroke = null;

                // Background image support
                this.backgroundImage = null;

                this.initializeControls();
                this.initializeCanvas();
                this.loadLEDPositions();
                this.updateMappingParams();
            }

            initializeControls() {
                const colorPicker = document.getElementById('colorPicker');
                const brushSize = document.getElementById('brushSize');
                const brushSizeValue = document.getElementById('brushSizeValue');
                const knnK = document.getElementById('knnK');
                const knnKValue = document.getElementById('knnKValue');
                const maxRadius = document.getElementById('maxRadius');
                const maxRadiusValue = document.getElementById('maxRadiusValue');
                const blendMode = document.getElementById('blendMode');
                const autoUpdate = document.getElementById('autoUpdate');
                const clearButton = document.getElementById('clearCanvas');
                const updateButton = document.getElementById('updateLEDs');
                const clearAllButton = document.getElementById('clearAll');
                const importCSVButton = document.getElementById('importCSV');
                const csvFileInput = document.getElementById('csvFileInput');
                const sampleColorsButton = document.getElementById('sampleColors');
                const importImageButton = document.getElementById('importImage');
                const imageFileInput = document.getElementById('imageFileInput');

                brushSize.addEventListener('input', (e) => {
                    brushSizeValue.textContent = e.target.value;
                });

                knnK.addEventListener('input', (e) => {
                    knnKValue.textContent = e.target.value;
                    this.updateMappingParams();
                    this.scheduleAutoUpdate();
                });

                maxRadius.addEventListener('input', (e) => {
                    maxRadiusValue.textContent = parseFloat(e.target.value).toFixed(2);
                    this.updateMappingParams();
                    this.scheduleAutoUpdate();
                });

                blendMode.addEventListener('change', (e) => {
                    this.updateStatus(`Blend mode: ${e.target.options[e.target.selectedIndex].text}`);
                });

                autoUpdate.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        this.updateStatus('Auto-update enabled');
                        this.scheduleAutoUpdate();
                    } else {
                        this.updateStatus('Auto-update disabled');
                        this.cancelAutoUpdate();
                    }
                });

                clearButton.addEventListener('click', () => {
                    this.clearCanvas();
                });

                updateButton.addEventListener('click', () => {
                    this.updateLEDs();
                });

                clearAllButton.addEventListener('click', () => {
                    this.clearAllLEDs();
                });

                importCSVButton.addEventListener('click', () => {
                    csvFileInput.click();
                });

                sampleColorsButton.addEventListener('click', () => {
                    this.sampleImageColors();
                });

                csvFileInput.addEventListener('change', (e) => {
                    this.handleCSVImport(e);
                });

                importImageButton.addEventListener('click', () => {
                    imageFileInput.click();
                });

                imageFileInput.addEventListener('change', (e) => {
                    this.handleImageImport(e);
                });
            }

            initializeCanvas() {
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.draw(e));
                this.canvas.addEventListener('mouseup', () => this.stopDrawing());
                this.canvas.addEventListener('mouseout', () => this.stopDrawing());
                this.canvas.addEventListener('contextmenu', (e) => this.handleRightClick(e));

                // Touch events for mobile
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.startDrawing(e.touches[0]);
                });
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.draw(e.touches[0]);
                });
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.stopDrawing();
                });
            }

            getCanvasPosition(e) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;

                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }

            handleMouseDown(e) {
                // Only start drawing on left click
                if (e.button === 0) {
                    this.startDrawing(e);
                }
            }

            handleRightClick(e) {
                e.preventDefault(); // Prevent context menu
                const pos = this.getCanvasPosition(e);
                this.addNewLED(pos.x, pos.y);
            }

            startDrawing(e) {
                this.isDrawing = true;
                const pos = this.getCanvasPosition(e);

                // Save current canvas state
                this.canvasStateBeforeStroke = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);

                // Start a new path
                this.currentPath = [pos];
                this.currentStrokeColor = document.getElementById('colorPicker').value;
                this.currentStrokeSize = parseInt(document.getElementById('brushSize').value);
                this.currentBlendMode = document.getElementById('blendMode').value;

                // Draw preview of current stroke
                this.drawCurrentStroke();
            }

            draw(e) {
                if (!this.isDrawing) return;

                const pos = this.getCanvasPosition(e);

                // Add point to current path
                this.currentPath.push(pos);

                // Restore canvas to state before stroke and redraw the entire stroke
                this.ctx.putImageData(this.canvasStateBeforeStroke, 0, 0);
                this.drawCurrentStroke();
            }

            drawCurrentStroke() {
                if (this.currentPath.length === 0) return;

                // Set blend mode for the entire stroke
                this.ctx.globalCompositeOperation = this.currentBlendMode;

                // Set up stroke properties
                this.ctx.strokeStyle = this.currentStrokeColor;
                this.ctx.lineWidth = this.currentStrokeSize * 2;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';

                // Draw the complete path as one stroke
                this.ctx.beginPath();

                if (this.currentPath.length === 1) {
                    // Single point - draw as circle
                    const pos = this.currentPath[0];
                    this.ctx.fillStyle = this.currentStrokeColor;
                    this.ctx.arc(pos.x, pos.y, this.currentStrokeSize, 0, 2 * Math.PI);
                    this.ctx.fill();
                } else {
                    // Multiple points - draw as path
                    this.ctx.moveTo(this.currentPath[0].x, this.currentPath[0].y);
                    for (let i = 1; i < this.currentPath.length; i++) {
                        this.ctx.lineTo(this.currentPath[i].x, this.currentPath[i].y);
                    }
                    this.ctx.stroke();
                }

                // Reset blend mode
                this.ctx.globalCompositeOperation = 'source-over';
            }

            stopDrawing() {
                if (!this.isDrawing || this.currentPath.length === 0) return;

                this.isDrawing = false;

                // Convert hex color to RGB for data storage
                const r = parseInt(this.currentStrokeColor.substr(1, 2), 16);
                const g = parseInt(this.currentStrokeColor.substr(3, 2), 16);
                const b = parseInt(this.currentStrokeColor.substr(5, 2), 16);

                // Sample points along the entire path for LED data
                this.samplePath(this.currentPath, r, g, b);

                // Clear current path
                this.currentPath = [];
                this.currentStrokeColor = null;
                this.currentStrokeSize = null;
                this.currentBlendMode = null;

                // Trigger auto-update if enabled
                this.scheduleAutoUpdate();
            }

            samplePath(path, r, g, b) {
                if (path.length === 0) return;

                if (path.length === 1) {
                    // Single point
                    const pos = path[0];
                    this.drawingData.push({
                        x: pos.x / this.canvas.width,
                        y: pos.y / this.canvas.height,
                        r: r,
                        g: g,
                        b: b
                    });
                } else {
                    // Sample along the path
                    const sampleRate = 3; // Sample every 3 pixels

                    for (let i = 0; i < path.length - 1; i++) {
                        const fromPos = path[i];
                        const toPos = path[i + 1];

                        const dx = toPos.x - fromPos.x;
                        const dy = toPos.y - fromPos.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        const numSamples = Math.max(1, Math.floor(distance / sampleRate));

                        for (let j = 0; j <= numSamples; j++) {
                            const t = numSamples > 0 ? j / numSamples : 0;
                            const x = fromPos.x + dx * t;
                            const y = fromPos.y + dy * t;

                            this.drawingData.push({
                                x: x / this.canvas.width,
                                y: y / this.canvas.height,
                                r: r,
                                g: g,
                                b: b
                            });
                        }
                    }
                }
            }

            clearCanvas() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawingData = [];
                this.drawBackgroundImage();
                this.drawLEDPositions();
                this.clearLEDColors();
                this.updateStatus('Canvas cleared');
            }

            drawBackgroundImage() {
                if (this.backgroundImage) {
                    // Draw background image, scaled to fit canvas
                    this.ctx.globalCompositeOperation = 'destination-over'; // Draw behind existing content
                    this.ctx.drawImage(this.backgroundImage, 0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.globalCompositeOperation = 'source-over'; // Reset to normal
                }
            }

            async loadLEDPositions() {
                try {
                    const response = await fetch('/led_positions');
                    const data = await response.json();

                    if (data.error) {
                        this.updateStatus(`Error: ${data.error}`);
                        return;
                    }

                    this.ledPositions = data.positions;
                    this.drawLEDPositions();
                    this.initializeLEDDisplay();
                    this.initializeLEDCanvas();
                    this.updateStatus(`Loaded ${data.count} LED positions`);

                    document.getElementById('ledPositions').textContent =
                        `LED positions loaded: ${data.count} LEDs`;

                } catch (error) {
                    this.updateStatus(`Error loading LED positions: ${error.message}`);
                }
            }

            drawLEDPositions() {
                // Ensure normal composite operation for LED markers
                this.ctx.globalCompositeOperation = 'source-over';

                // Draw LED positions as small circles on the canvas
                this.ctx.strokeStyle = '#00ff00';
                this.ctx.lineWidth = 2;

                for (const [ledIndex, position] of Object.entries(this.ledPositions)) {
                    const x = position[0] * this.canvas.width;
                    const y = position[1] * this.canvas.height;

                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    this.ctx.stroke();

                    // Label the LED with background for better visibility over images
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(x + 5, y - 17, 20, 14);
                    this.ctx.fillStyle = '#00ff00';
                    this.ctx.font = '12px Arial';
                    this.ctx.fillText(ledIndex, x + 6, y - 6);
                }
            }

            initializeLEDDisplay() {
                const ledGrid = document.getElementById('ledGrid');
                ledGrid.innerHTML = '';

                const sortedLEDs = Object.keys(this.ledPositions)
                    .map(Number)
                    .sort((a, b) => a - b);

                for (const ledIndex of sortedLEDs) {
                    this.addLEDToDisplay(ledIndex);
                }
            }

            async updateLEDs() {
                if (this.drawingData.length === 0) {
                    this.updateStatus('No drawing data to process');
                    return;
                }

                // Get current parameter values
                const k = parseInt(document.getElementById('knnK').value);
                const maxRadius = parseFloat(document.getElementById('maxRadius').value);

                this.updateStatus(`Updating LED colors (K=${k}, max_radius=${maxRadius})...`);

                try {
                    const response = await fetch('/update_colors', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            drawing_data: this.drawingData,
                            k: k,
                            max_radius: maxRadius
                        })
                    });

                    const data = await response.json();

                    if (data.error) {
                        this.updateStatus(`Error: ${data.error}`);
                        return;
                    }

                    this.displayLEDColors(data.led_colors);
                    this.updateStatus(`Updated ${Object.keys(data.led_colors).length} LED colors`);

                } catch (error) {
                    this.updateStatus(`Error updating LEDs: ${error.message}`);
                }
            }

            displayLEDColors(ledColors) {
                // Update the current LED colors state
                this.currentLedColors = ledColors;

                // Update the LED grid display
                for (const [ledIndex, color] of Object.entries(ledColors)) {
                    const colorDiv = document.getElementById(`led-color-${ledIndex}`);
                    const rgbDiv = document.getElementById(`led-rgb-${ledIndex}`);

                    if (colorDiv && rgbDiv) {
                        const rgbColor = `rgb(${color.r}, ${color.g}, ${color.b})`;
                        colorDiv.style.backgroundColor = rgbColor;
                        rgbDiv.textContent = `RGB: ${color.r},${color.g},${color.b}`;
                    }
                }

                // Update the LED preview canvas
                this.updateLEDCanvas();
            }

            clearLEDColors() {
                // Reset the current LED colors state
                this.currentLedColors = {};

                // Reset all LED colors to black/off
                for (const ledIndex of Object.keys(this.ledPositions)) {
                    const colorDiv = document.getElementById(`led-color-${ledIndex}`);
                    const rgbDiv = document.getElementById(`led-rgb-${ledIndex}`);

                    if (colorDiv && rgbDiv) {
                        colorDiv.style.backgroundColor = '#000';
                        rgbDiv.textContent = 'RGB: 0,0,0';
                    }
                }

                // Clear the LED preview canvas
                this.initializeLEDCanvas();
            }

            updateStatus(message) {
                document.getElementById('statusText').textContent = message;
                console.log(message);
            }

            updateMappingParams() {
                const k = document.getElementById('knnK').value;
                const maxRadius = parseFloat(document.getElementById('maxRadius').value).toFixed(2);
                document.getElementById('mappingParams').textContent =
                    `K-NN Parameters: K=${k}, Max Radius=${maxRadius}`;
            }

            scheduleAutoUpdate() {
                // Only auto-update if checkbox is checked and there's drawing data
                const autoUpdate = document.getElementById('autoUpdate');
                if (!autoUpdate.checked || this.drawingData.length === 0) {
                    return;
                }

                // Cancel any pending auto-update
                this.cancelAutoUpdate();

                // Schedule a new auto-update with debouncing (500ms delay)
                this.autoUpdateTimeout = setTimeout(() => {
                    this.updateLEDs();
                }, 500);
            }

            cancelAutoUpdate() {
                if (this.autoUpdateTimeout) {
                    clearTimeout(this.autoUpdateTimeout);
                    this.autoUpdateTimeout = null;
                }
            }

            initializeLEDCanvas() {
                // Clear the LED canvas with a dark background
                this.ledCtx.fillStyle = '#1a1a1a';
                this.ledCtx.fillRect(0, 0, this.ledCanvas.width, this.ledCanvas.height);

                // Draw LED positions as small circles
                for (const [ledIndex, position] of Object.entries(this.ledPositions)) {
                    const x = position[0] * this.ledCanvas.width;
                    const y = position[1] * this.ledCanvas.height;

                    // Draw a small gray circle for each LED position
                    this.ledCtx.fillStyle = '#333333';
                    this.ledCtx.beginPath();
                    this.ledCtx.arc(x, y, 8, 0, 2 * Math.PI);
                    this.ledCtx.fill();

                    // Draw LED index
                    this.ledCtx.fillStyle = '#666666';
                    this.ledCtx.font = '10px Arial';
                    this.ledCtx.textAlign = 'center';
                    this.ledCtx.fillText(ledIndex, x, y + 3);
                }
            }

            updateLEDCanvas() {
                // Reinitialize the canvas to clear it
                this.initializeLEDCanvas();

                // Draw colored LEDs
                for (const [ledIndex, color] of Object.entries(this.currentLedColors)) {
                    const position = this.ledPositions[ledIndex];
                    if (position) {
                        const x = position[0] * this.ledCanvas.width;
                        const y = position[1] * this.ledCanvas.height;

                        // Draw the LED with its actual color
                        const rgbColor = `rgb(${color.r}, ${color.g}, ${color.b})`;
                        this.ledCtx.fillStyle = rgbColor;
                        this.ledCtx.beginPath();
                        this.ledCtx.arc(x, y, 8, 0, 2 * Math.PI);
                        this.ledCtx.fill();

                        // Create ultra-intense luminous glow effect
                        // First create a radial gradient for realistic light emission
                        const gradient = this.ledCtx.createRadialGradient(x, y, 2, x, y, 30);
                        gradient.addColorStop(0, rgbColor);
                        gradient.addColorStop(0.4, rgbColor);
                        gradient.addColorStop(1, 'rgba(0,0,0,0)');

                        // First base glow layer
                        this.ledCtx.shadowColor = rgbColor;
                        this.ledCtx.shadowBlur = 25; // Increased from 10
                        this.ledCtx.beginPath();
                        this.ledCtx.arc(x, y, 12, 0, 2 * Math.PI); // Larger radius
                        this.ledCtx.fillStyle = rgbColor;
                        this.ledCtx.fill();

                        // Reset shadow blur
                        this.ledCtx.shadowBlur = 0;

                        // Draw LED index in contrasting color
                        const brightness = (color.r * 0.299 + color.g * 0.587 + color.b * 0.114);
                        this.ledCtx.fillStyle = brightness > 128 ? '#000000' : '#ffffff';
                        this.ledCtx.font = 'bold 10px Arial';
                        this.ledCtx.textAlign = 'center';
                        this.ledCtx.fillText(ledIndex, x, y + 3);
                    }
                }
            }

            async addNewLED(x, y) {
                // Convert canvas coordinates to normalized coordinates
                const normalizedX = x / this.canvas.width;
                const normalizedY = y / this.canvas.height;

                // Find the next available LED index
                const existingIndices = Object.keys(this.ledPositions).map(Number);
                const nextIndex = existingIndices.length > 0 ? Math.max(...existingIndices) + 1 : 0;

                try {
                    const response = await fetch('/add_led', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            led_index: nextIndex,
                            x: normalizedX,
                            y: normalizedY
                        })
                    });

                    const data = await response.json();

                    if (data.error) {
                        this.updateStatus(`Error adding LED: ${data.error}`);
                        return;
                    }

                    // Update local LED positions
                    this.ledPositions[nextIndex] = [normalizedX, normalizedY];

                    // Redraw both canvases
                    this.drawLEDPositions();
                    this.initializeLEDCanvas();

                    // Add to LED display grid
                    this.addLEDToDisplay(nextIndex);

                    // Sample color from background image if available
                    if (this.backgroundImage) {
                        this.sampleSingleLEDColor(nextIndex);
                    }

                    this.updateStatus(`Added LED ${nextIndex} at position (${normalizedX.toFixed(3)}, ${normalizedY.toFixed(3)})`);

                } catch (error) {
                    this.updateStatus(`Error adding LED: ${error.message}`);
                }
            }

            addLEDToDisplay(ledIndex) {
                const ledGrid = document.getElementById('ledGrid');

                const ledItem = document.createElement('div');
                ledItem.className = 'led-item';
                ledItem.id = `led-item-${ledIndex}`;
                ledItem.innerHTML = `
                    <button class="led-delete" onclick="app.deleteLED(${ledIndex})">
                        <i class="ph ph-x"></i>
                    </button>
                    <div>LED ${ledIndex}</div>
                    <div class="led-color" id="led-color-${ledIndex}" style="background-color: #000;"></div>
                    <div id="led-rgb-${ledIndex}">RGB: 0,0,0</div>
                `;
                ledGrid.appendChild(ledItem);
            }

            async handleCSVImport(event) {
                const file = event.target.files[0];
                if (!file) return;

                // Validate file type
                if (file.type !== 'text/csv' && !file.name.toLowerCase().endsWith('.csv')) {
                    this.updateStatus('Error: Please select a valid CSV file');
                    return;
                }

                try {
                    const text = await file.text();
                    const lines = text.split('\n').filter(line => line.trim());

                    if (lines.length === 0) {
                        this.updateStatus('Error: CSV file is empty');
                        return;
                    }

                    // Parse CSV (expect: led_index,x,y)
                    const header = lines[0].toLowerCase();
                    if (!header.includes('led_index') || !header.includes('x') || !header.includes('y')) {
                        this.updateStatus('Error: CSV must have columns: led_index, x, y');
                        return;
                    }

                    let importedCount = 0;
                    // Use canvas dimensions for normalization since that's our coordinate system
                    const canvasWidth = this.canvas.width;
                    const canvasHeight = this.canvas.height;

                    for (let i = 1; i < lines.length; i++) {
                        const parts = lines[i].split(',').map(p => p.trim());
                        if (parts.length >= 3) {
                            const ledIndex = parseInt(parts[0]);
                            const x = parseFloat(parts[1]);
                            const y = parseFloat(parts[2]);

                            if (!isNaN(ledIndex) && !isNaN(x) && !isNaN(y)) {
                                // Normalize coordinates
                                const normalizedX = x / canvasWidth;
                                const normalizedY = y / canvasHeight;

                                // Add LED using existing method
                                this.ledPositions[ledIndex] = [normalizedX, normalizedY];
                                this.addLEDToDisplay(ledIndex);
                                importedCount++;
                            }
                        }
                    }

                    // Update canvases and mapper
                    this.drawLEDPositions();
                    this.initializeLEDCanvas();

                    this.updateStatus(`Imported ${importedCount} LEDs from CSV`);

                } catch (error) {
                    this.updateStatus(`Error reading CSV: ${error.message}`);
                }

                // Reset file input
                event.target.value = '';
            }

            async handleImageImport(event) {
                const file = event.target.files[0];
                if (!file) return;

                // Validate file type
                if (!file.type.startsWith('image/')) {
                    this.updateStatus('Error: Please select a valid image file');
                    return;
                }

                try {
                    // Create image object
                    const img = new Image();

                    // Load image
                    await new Promise((resolve, reject) => {
                        img.onload = resolve;
                        img.onerror = reject;
                        img.src = URL.createObjectURL(file);
                    });

                    // Store background image
                    this.backgroundImage = img;

                    // Clear canvas and redraw with background
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.drawBackgroundImage();
                    this.drawLEDPositions();

                    // Sample colors from image at LED positions
                    this.sampleImageColors();

                    this.updateStatus(`Image imported: ${file.name} (${img.naturalWidth}x${img.naturalHeight}) - Colors sampled`);

                    // Clean up object URL
                    URL.revokeObjectURL(img.src);

                } catch (error) {
                    this.updateStatus(`Error loading image: ${error.message}`);
                }

                // Reset file input
                event.target.value = '';
            }

            sampleImageColors() {
                if (!this.backgroundImage || Object.keys(this.ledPositions).length === 0) {
                    return;
                }

                // Create a temporary canvas to sample from the image
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = this.canvas.width;
                tempCanvas.height = this.canvas.height;
                const tempCtx = tempCanvas.getContext('2d');

                // Draw the image on the temporary canvas
                tempCtx.drawImage(this.backgroundImage, 0, 0, tempCanvas.width, tempCanvas.height);

                // Sample colors at each LED position
                const ledColors = {};

                for (const [ledIndex, position] of Object.entries(this.ledPositions)) {
                    const x = Math.round(position[0] * this.canvas.width);
                    const y = Math.round(position[1] * this.canvas.height);

                    // Get pixel data at LED position
                    const imageData = tempCtx.getImageData(x, y, 1, 1);
                    const pixel = imageData.data;

                    const r = pixel[0];
                    const g = pixel[1];
                    const b = pixel[2];

                    ledColors[ledIndex] = { r, g, b };
                }

                // Update LED display with sampled colors
                this.displayLEDColors(ledColors);

                // Update the status
                const colorCount = Object.keys(ledColors).length;
                this.updateStatus(`Sampled ${colorCount} LED colors from image`);
            }

            sampleSingleLEDColor(ledIndex) {
                if (!this.backgroundImage || !this.ledPositions[ledIndex]) {
                    return;
                }

                // Create a temporary canvas to sample from the image
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = this.canvas.width;
                tempCanvas.height = this.canvas.height;
                const tempCtx = tempCanvas.getContext('2d');

                // Draw the image on the temporary canvas
                tempCtx.drawImage(this.backgroundImage, 0, 0, tempCanvas.width, tempCanvas.height);

                // Get LED position
                const position = this.ledPositions[ledIndex];
                const x = Math.round(position[0] * this.canvas.width);
                const y = Math.round(position[1] * this.canvas.height);

                // Get pixel data at LED position
                const imageData = tempCtx.getImageData(x, y, 1, 1);
                const pixel = imageData.data;

                const r = pixel[0];
                const g = pixel[1];
                const b = pixel[2];

                // Update LED display with sampled color
                const ledColors = {};
                ledColors[ledIndex] = { r, g, b };
                this.displayLEDColors(ledColors);

                this.updateStatus(`Sampled color for LED ${ledIndex}: RGB(${r}, ${g}, ${b})`);
            }

            deleteLED(ledIndex) {
                // Remove from positions
                delete this.ledPositions[ledIndex];

                // Remove from display
                const ledItem = document.getElementById(`led-item-${ledIndex}`);
                if (ledItem) {
                    ledItem.remove();
                }

                // Update canvases
                this.drawLEDPositions();
                this.initializeLEDCanvas();

                this.updateStatus(`Deleted LED ${ledIndex}`);
            }

            clearAllLEDs() {
                if (Object.keys(this.ledPositions).length === 0) {
                    this.updateStatus('No LEDs to clear');
                    return;
                }

                if (confirm('Are you sure you want to delete all LEDs? This cannot be undone.')) {
                    // Clear all data
                    this.ledPositions = {};
                    this.currentLedColors = {};

                    // Clear displays
                    const ledGrid = document.getElementById('ledGrid');
                    ledGrid.innerHTML = '';

                    // Update canvases
                    this.drawLEDPositions();
                    this.initializeLEDCanvas();

                    this.updateStatus('All LEDs cleared');
                }
            }
        }

        // Global reference for delete button callbacks
        let app;

        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            app = new LEDDrawingApp();
        });
    </script>
</body>
</html>
