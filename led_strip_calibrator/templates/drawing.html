<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LED Strip Interactive Drawing</title>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/lumical.css') }}">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>LumiCal</h1>
            <p>Draw on the canvas to control your LED strip colors</p>
            <p><small><strong>Left-click:</strong> Draw â€¢ <strong>Right-click:</strong> Add new LED</small></p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="colorPicker">Color:</label>
                <input type="color" id="colorPicker" value="#ff0000">
            </div>

            <div class="control-group">
                <label for="brushSize">Brush Size:</label>
                <input type="range" id="brushSize" min="1" max="50" value="10">
                <span id="brushSizeValue">5</span>
            </div>




            <div class="control-group">
                <label for="overlayFile">Load Overlay:</label>
                <input type="file" id="overlayFile" accept="image/*">
            </div>

            <button id="clearCanvas" class="clear">Clear Canvas</button>

            <div class="break"></div> <!-- break -->
        </div>

        <div class="color-palette">
            <div class="color-swatch selected" data-color="#ff0000" style="background-color: #ff0000;"></div>
            <div class="color-swatch" data-color="#ff8000" style="background-color: #ff8000;"></div>
            <div class="color-swatch" data-color="#ffff00" style="background-color: #ffff00;"></div>
            <div class="color-swatch" data-color="#80ff00" style="background-color: #80ff00;"></div>
            <div class="color-swatch" data-color="#00ff00" style="background-color: #00ff00;"></div>
            <div class="color-swatch" data-color="#00ff80" style="background-color: #00ff80;"></div>
            <div class="color-swatch" data-color="#00ffff" style="background-color: #00ffff;"></div>
            <div class="color-swatch" data-color="#0080ff" style="background-color: #0080ff;"></div>
            <div class="color-swatch" data-color="#0000ff" style="background-color: #0000ff;"></div>
            <div class="color-swatch" data-color="#8000ff" style="background-color: #8000ff;"></div>
            <div class="color-swatch" data-color="#ff00ff" style="background-color: #ff00ff;"></div>
            <div class="color-swatch" data-color="#ff0080" style="background-color: #ff0080;"></div>
            <div class="color-swatch" data-color="#ffffff" style="background-color: #ffffff;"></div>
            <div class="color-swatch" data-color="#000000" style="background-color: #000000;"></div>
        </div>

        <div class="canvas-container">
            <div class="canvas-wrapper">
                <h3>Drawing Canvas</h3>
                <div class="canvas-stack">
                    <canvas id="overlayCanvas" width="800" height="600"></canvas>
                    <canvas id="drawingCanvas" width="800" height="600"></canvas>
                </div>
            </div>
            <div class="canvas-wrapper">
                <h3>LED Preview</h3>
                <canvas id="ledCanvas" width="800" height="600" class="single-canvas"></canvas>
            </div>
        </div>

        <div class="led-display">
            <h3>LED Colors</h3>
            <div style="margin-bottom: 15px;">
                <input type="file" id="jsonFileInput" accept=".json,text/json" style="display: none;">
                <button id="importJSON" style="margin-right: 10px;">Import LED Coordinates</button>
                <button id="exportCSV" style="margin-right: 10px;">Export LED Pattern as CSV</button>
                <button id="clearAll" class="clear">Clear All LEDs</button>
            </div>
            <div class="led-grid" id="ledGrid">
                <!-- LED color displays will be populated here -->
            </div>
        </div>

        <div class="status">
            <h3>Status</h3>
            <div id="statusText">Ready to draw</div>
            <div id="ledPositions">Loading LED positions...</div>
        </div>
    </div>

    <script src="{{ url_for('static', filename='js/canvas_controller.js') }}"></script>
    <script>
        // WebSocket connection and client-specific logic
        const sessionClientId = "{{ session['client_id'] }}";
        const socket = io();

        // Make these globally accessible for LED manager
        window.sessionClientId = sessionClientId;
        window.socket = socket;

        console.log('Page loaded, client ID:', sessionClientId);

        // WebSocket event handlers
        socket.on('connect', function() {
            console.log('Connected to server via WebSocket');
        });

        socket.on('disconnect', function() {
            console.log('Disconnected from server');
        });

        socket.on('update', function(data) {
            console.log('Received update:', data);

            if (data.clear) {
                handleClearCanvas(data);
                // Clear LEDs after canvas clear
                if (window.ledManager) {
                    window.ledManager.clearLEDColors();
                }
            } else if (data.fullStateImage && data.clientId !== sessionClientId) {
                // Use the full state image instead of just the delta for proper layering
                console.log(`Received full state from client ${data.clientId}, applying to canvas`);
                const img = new Image();
                img.onload = function() {
                    // Clear and apply the full state from server
                    drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                    persistentCtx.clearRect(0, 0, persistentCanvas.width, persistentCanvas.height);

                    drawingCtx.drawImage(img, 0, 0);
                    persistentCtx.drawImage(img, 0, 0);
                    console.log(`Applied full state from client ${data.clientId}`);

                    // Update LEDs with backend-computed colors if available
                    if (window.ledManager && data.led_colors) {
                        window.ledManager.displayLEDColors(data.led_colors);
                    }
                };
                img.src = data.fullStateImage;
            } else if (data.deltaImage) {
                handleReceivedDelta(data, sessionClientId);
            }

            // Always update LEDs with backend-computed colors when available
            if (window.ledManager && data.led_colors) {
                window.ledManager.displayLEDColors(data.led_colors);
            }
        });

        socket.on('init_canvas', function(data) {
            console.log('Received initial canvas state:', data);
            if (data.fullStateImage) {
                const img = new Image();
                img.onload = function() {
                    drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                    persistentCtx.clearRect(0, 0, persistentCanvas.width, persistentCanvas.height);
                    drawingCtx.drawImage(img, 0, 0);
                    persistentCtx.drawImage(img, 0, 0);
                    console.log('Applied initial canvas state');
                    
                    // Update LEDs with initial backend-computed colors if available
                    if (window.ledManager && data.led_colors) {
                        window.ledManager.displayLEDColors(data.led_colors);
                        console.log('Applied initial LED colors');
                    }
                };
                img.src = data.fullStateImage;
            } else if (data.led_colors && window.ledManager) {
                // Even if no canvas state, apply LED colors
                window.ledManager.displayLEDColors(data.led_colors);
                console.log('Applied initial LED colors (no canvas state)');
            }
        });

        // Wait for canvas controller to be ready, then initialize functions
        function waitForCanvasController() {
            if (window.sendCanvasToServerFunction && window.clearCanvasFunction) {
                console.log('Canvas controller functions are ready');

                // Clear canvas button event handler
                const clearButton = document.getElementById('clearCanvas');
                if (clearButton) {
                    clearButton.addEventListener('click', () => {
                        window.clearCanvasFunction(sessionClientId, socket);
                    });
                }

                // Send canvas updates via WebSocket
                setInterval(() => {
                    window.sendCanvasToServerFunction(sessionClientId, socket);
                }, 50);
            } else {
                console.log('Waiting for canvas controller functions...');
                // Check again in 100ms
                setTimeout(waitForCanvasController, 100);
            }
        }

        // Start waiting for canvas controller
        waitForCanvasController();
    </script>
    <script>
        // LED Management functionality that integrates with canvas_controller
        class LEDManager {
            constructor() {
                this.ledPositions = {};
                this.currentLedColors = {};

                this.initializeControls();
                this.loadLEDPositions();
            }

            initializeControls() {
                const clearAllButton = document.getElementById('clearAll');
                const importJSONButton = document.getElementById('importJSON');
                const exportCSVButton = document.getElementById('exportCSV');
                const jsonFileInput = document.getElementById('jsonFileInput');

                clearAllButton.addEventListener('click', () => {
                    this.clearAllLEDs();
                });

                importJSONButton.addEventListener('click', () => {
                    jsonFileInput.click();
                });

                exportCSVButton.addEventListener('click', () => {
                    this.exportCSV();
                });

                jsonFileInput.addEventListener('change', (e) => {
                    this.handleJSONImport(e);
                });


                // Add right-click handler to drawing canvas for adding LEDs
                const ledCanvas = document.getElementById('ledCanvas');

                ledCanvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    const rect = ledCanvas.getBoundingClientRect();
                    const scaleX = ledCanvas.width / rect.width;
                    const scaleY = ledCanvas.height / rect.height;
                    const x = (e.clientX - rect.left) * scaleX;
                    const y = (e.clientY - rect.top) * scaleY;
                    this.addNewLED(x, y);
                });
            }

            async loadLEDPositions() {
                try {
                    const response = await fetch('/led_positions');
                    const data = await response.json();

                    if (data.error) {
                        this.updateStatus(`Error: ${data.error}`);
                        return;
                    }

                    this.ledPositions = data.positions;
                    this.initializeLEDDisplay();
                    this.initializeLEDCanvas();
                    this.updateStatus(`Loaded ${data.count} LED positions`);

                    document.getElementById('ledPositions').textContent =
                        `LED positions loaded: ${data.count} LEDs`;

                } catch (error) {
                    this.updateStatus(`Error loading LED positions: ${error.message}`);
                }
            }

            initializeLEDDisplay() {
                const ledGrid = document.getElementById('ledGrid');
                ledGrid.innerHTML = '';

                const sortedLEDs = Object.keys(this.ledPositions)
                    .map(Number)
                    .sort((a, b) => a - b);

                for (const ledIndex of sortedLEDs) {
                    this.addLEDToDisplay(ledIndex);
                }
            }

            addLEDToDisplay(ledIndex) {
                const ledGrid = document.getElementById('ledGrid');

                const ledItem = document.createElement('div');
                ledItem.className = 'led-item';
                ledItem.id = `led-item-${ledIndex}`;
                ledItem.innerHTML = `
                    <button class="led-delete" onclick="ledManager.deleteLED(${ledIndex})">
                        <i class="ph ph-trash-simple"></i>
                    </button>
                    <div>LED ${ledIndex}</div>
                    <div class="led-color" id="led-color-${ledIndex}" style="background-color: #000;"></div>
                    <div id="led-rgb-${ledIndex}">RGB: 0,0,0</div>
                `;
                ledGrid.appendChild(ledItem);
            }

            initializeLEDCanvas() {
                const ledCanvas = document.getElementById('ledCanvas');
                const ledCtx = ledCanvas.getContext('2d');

                // Clear the LED canvas with a dark background
                ledCtx.fillStyle = '#1a1a1a';
                ledCtx.fillRect(0, 0, ledCanvas.width, ledCanvas.height);

                // Draw LED positions as small circles
                for (const [ledIndex, position] of Object.entries(this.ledPositions)) {
                    const x = position[0] * ledCanvas.width;
                    const y = position[1] * ledCanvas.height;

                    // Draw a small gray circle for each LED position
                    ledCtx.fillStyle = '#333333';
                    ledCtx.beginPath();
                    ledCtx.arc(x, y, 8, 0, 2 * Math.PI);
                    ledCtx.fill();

                    // Draw LED index
                    ledCtx.fillStyle = '#666666';
                    ledCtx.font = '10px Arial';
                    ledCtx.textAlign = 'center';
                    ledCtx.fillText(ledIndex, x, y + 3);
                }
            }

            displayLEDColors(ledColors) {
                // Convert backend format to internal format if needed
                const convertedColors = {};

                for (const [ledIndex, colorData] of Object.entries(ledColors)) {
                    // Backend sends: {"rgb": [255, 0, 0], "color": "#ff0000", "position": {...}}
                    // Convert to internal format: {"r": 255, "g": 0, "b": 0}
                    if (colorData.rgb && Array.isArray(colorData.rgb)) {
                        convertedColors[ledIndex] = {
                            r: colorData.rgb[0],
                            g: colorData.rgb[1],
                            b: colorData.rgb[2]
                        };
                    } else if (colorData.r !== undefined) {
                        // Already in internal format
                        convertedColors[ledIndex] = colorData;
                    }
                }

                // Update the current LED colors state
                this.currentLedColors = convertedColors;

                // Update the LED grid display
                for (const [ledIndex, color] of Object.entries(convertedColors)) {
                    const colorDiv = document.getElementById(`led-color-${ledIndex}`);
                    const rgbDiv = document.getElementById(`led-rgb-${ledIndex}`);

                    if (colorDiv && rgbDiv) {
                        const rgbColor = `rgb(${color.r}, ${color.g}, ${color.b})`;
                        colorDiv.style.backgroundColor = rgbColor;
                        rgbDiv.textContent = `RGB: ${color.r},${color.g},${color.b}`;
                    }
                }

                // Update the LED preview canvas
                this.updateLEDCanvas();
            }

            clearLEDColors() {
                // Clear all LED colors to black
                const clearedColors = {};
                for (const ledIndex in this.ledPositions) {
                    clearedColors[ledIndex] = { r: 0, g: 0, b: 0 };
                }
                this.displayLEDColors(clearedColors);
            }

            updateLEDCanvas() {
                const ledCanvas = document.getElementById('ledCanvas');
                const ledCtx = ledCanvas.getContext('2d');

                // Reinitialize the canvas to clear it
                this.initializeLEDCanvas();

                // Draw colored LEDs
                for (const [ledIndex, color] of Object.entries(this.currentLedColors)) {
                    const position = this.ledPositions[ledIndex];
                    if (position) {
                        const x = position[0] * ledCanvas.width;
                        const y = position[1] * ledCanvas.height;

                        // Draw the LED with its actual color
                        const rgbColor = `rgb(${color.r}, ${color.g}, ${color.b})`;
                        ledCtx.fillStyle = rgbColor;
                        ledCtx.beginPath();
                        ledCtx.arc(x, y, 10, 0, 2 * Math.PI);
                        ledCtx.fill();

                        // Create glow effect
                        ledCtx.shadowColor = rgbColor;
                        ledCtx.shadowBlur = 25;
                        ledCtx.beginPath();
                        ledCtx.arc(x, y, 16, 0, 2 * Math.PI);
                        ledCtx.fillStyle = rgbColor;
                        ledCtx.fill();
                        ledCtx.shadowBlur = 0;

                        // Draw LED index
                        const brightness = (color.r * 0.299 + color.g * 0.587 + color.b * 0.114);
                        ledCtx.fillStyle = brightness > 128 ? '#000000' : '#ffffff';
                        ledCtx.font = 'bold 10px Arial';
                        ledCtx.textAlign = 'center';
                        ledCtx.fillText(ledIndex, x, y + 3);
                    }
                }
            }

            async addNewLED(x, y) {
                // Convert canvas coordinates to normalized coordinates
                const drawingCanvas = document.getElementById('drawingCanvas');
                const normalizedX = x / drawingCanvas.width;
                const normalizedY = y / drawingCanvas.height;

                // Find the next available LED index
                const existingIndices = Object.keys(this.ledPositions).map(Number);
                const nextIndex = existingIndices.length > 0 ? Math.max(...existingIndices) + 1 : 0;

                try {
                    const response = await fetch('/add_led', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            led_index: nextIndex,
                            x: normalizedX,
                            y: normalizedY
                        })
                    });

                    const data = await response.json();

                    if (data.error) {
                        this.updateStatus(`Error adding LED: ${data.error}`);
                        return;
                    }

                    // Update local LED positions
                    this.ledPositions[nextIndex] = [normalizedX, normalizedY];

                    // Redraw LED canvas and add to display
                    this.initializeLEDCanvas();
                    this.addLEDToDisplay(nextIndex);

                    this.updateStatus(`Added LED ${nextIndex} at position (${normalizedX.toFixed(3)}, ${normalizedY.toFixed(3)})`);

                } catch (error) {
                    this.updateStatus(`Error adding LED: ${error.message}`);
                }
            }

            deleteLED(ledIndex) {
                // Remove from positions
                delete this.ledPositions[ledIndex];

                // Remove from display
                const ledItem = document.getElementById(`led-item-${ledIndex}`);
                if (ledItem) {
                    ledItem.remove();
                }

                // Update canvas
                this.initializeLEDCanvas();

                this.updateStatus(`Deleted LED ${ledIndex}`);
            }

            clearAllLEDs() {
                if (Object.keys(this.ledPositions).length === 0) {
                    this.updateStatus('No LEDs to clear');
                    return;
                }

                if (confirm('Are you sure you want to delete all LEDs? This cannot be undone.')) {
                    // Clear all data
                    this.ledPositions = {};
                    this.currentLedColors = {};

                    // Clear displays
                    const ledGrid = document.getElementById('ledGrid');
                    ledGrid.innerHTML = '';

                    // Update canvas
                    this.initializeLEDCanvas();

                    this.updateStatus('All LEDs cleared');
                }
            }

            exportCSV() {
                // Create CSV content with headers
                let csvContent = "Index,Red,Green,Blue\\n";

                // Create export data from current LED colors
                for (const [ledIndex, position] of Object.entries(this.ledPositions)) {
                    const color = this.currentLedColors[ledIndex] || { r: 0, g: 0, b: 0 };
                    csvContent += `${ledIndex},${color.r},${color.g},${color.b}\\n`;
                }

                // Create a blob and download link
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'led_colors.csv';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.updateStatus('LED colors exported to CSV');
            }

            async handleJSONImport(event) {
                const file = event.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const jsonData = JSON.parse(text);

                    if (!jsonData.coords) {
                        this.updateStatus('Error: JSON file must contain a "coords" field');
                        return;
                    }

                    const lines = jsonData.coords.split('\\n').filter(line => line.trim());
                    const calibration_width = jsonData.width;
                    const calibration_height = jsonData.height;

                    if (lines.length === 0) {
                        this.updateStatus('Error: CSV data is empty');
                        return;
                    }

                    let importedCount = 0;

                    for (let i = 1; i < lines.length; i++) {
                        const parts = lines[i].split(',').map(p => p.trim());
                        if (parts.length >= 3) {
                            const ledIndex = parseInt(parts[0]);
                            const x = parseFloat(parts[1]);
                            const y = parseFloat(parts[2]);

                            if (!isNaN(ledIndex) && !isNaN(x) && !isNaN(y)) {
                                const normalizedX = x / calibration_width;
                                const normalizedY = y / calibration_height;

                                this.ledPositions[ledIndex] = [normalizedX, normalizedY];
                                this.addLEDToDisplay(ledIndex);
                                importedCount++;
                            }
                        }
                    }

                    this.initializeLEDCanvas();
                    this.updateStatus(`Imported ${importedCount} LEDs from JSON`);

                } catch (error) {
                    this.updateStatus(`Error reading JSON: ${error.message}`);
                }

                event.target.value = '';
            }




            updateStatus(message) {
                document.getElementById('statusText').textContent = message;
                console.log(message);
            }
        }

        // Global reference for LED management
        let ledManager;

        // Initialize LED management when page loads
        document.addEventListener('DOMContentLoaded', () => {
            ledManager = new LEDManager();
            // Make ledManager globally accessible
            window.ledManager = ledManager;

            // Hook into canvas updates - LED colors come from backend via WebSocket response
            const originalSendCanvasToServer = window.sendCanvasToServer;
            if (originalSendCanvasToServer && typeof originalSendCanvasToServer === 'function') {
                window.sendCanvasToServer = function() {
                    originalSendCanvasToServer();
                    // LED colors will be updated via WebSocket 'update' event with backend-computed values
                };
            }
        });
    </script>
</body>
</html>
